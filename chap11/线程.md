# 11.线程

## 11.1 引言
了解如何使用多个线程在单进程环境中执行多个任务。
一个进程中的所有线程都可以访问该进程的组成部分，如文件描述符和内存。
讨论同步机制，防止多个线程在共享资源时出现不一致的问题。

## 11.2 线程概念
典型的 unix 进程可以看作只有一个线程，一个进程在某一时刻只能做一件事情，
有了多个线程之后，就可以把程序设计成在某一刻能够做不止一件事情，每个线程
处理各自独立的任务。

每个线程都有表示执行环境所必需的信息，包括标识线程的线程 ID，一组寄存器，
栈，调度优先级和策略，信号屏蔽字，errno 变量以及线程私有数据。一个进程的
所有信息对该进程的所有线程是共享的，包括可执行程序代码，程序的全局内存和堆
内存，栈以及文件描述符。

## 11.3 线程标识
每个线程有一个线程 ID，线程 ID 只有在它所属的进程上下文中才有意义。
线程 ID 是用 pthread_t 数据类型来表示的。
```c++
#include <pthread.h>

// 返回值：相等返回非 0 数值，否则返回 0
int pthread_equal(pthread_t tid1, pthread_t tid2);

// 返回值：调用线程的线程 ID
pthread_t pthread_self(void);
```

## 11.4 线程创建
使用 pthread_create 创建一个新的线程，新创建线程的线程 ID 被设置为 tidp 执行的内存单元
attr 用于指定不同的线程属性，将其设置为 NULL 时，表示创建一个具有默认属性的线程。
新创建的线程从 start_rtn 函数的地址开始运行，如果传递的参数有多个，需要把这些参数放在一个
结构中，然后把这个结构的地址作为 arg 参数传入。

```c++
#include <pthread.h>

// 返回值：成功返回 0，否则返回错误编号
int pthread_create(pthread_t* tidp, const pthread_attr_t* attr, void* (*start_rtn)(void *), void* arg);
```

线程创建并不能保证哪个线程会先运行：是新创建的线程还是调用线程。

## 11.5 线程终止
进程中的任意线程调用了 exit, _Exit 或者 _exit，那么整个进程就会终止。
单个线程可以通过 3 中方式退出，因此可以在不终止整个进程的情况下，停止它的控制流。
* 线程可以简单地从启动例程中返回，返回值是线程的退出码。
* 线程可以被同一进程中的其他线程取消。
* 线程调用 pthread_exit.

```c++
#incude <pthread.h>

void pthread_exit(void *rval_ptr);

// 返回值：成功返回 0，否则返回错误编号
int pthread_join(pthread_t thread, void** rval_ptr);
```

pthread_join 调用线程将一直阻塞，直到指定的线程调用 pthread_exit,从启动例程中返回或者被取消。

